{"version": "1.132.1", "results": [{"check_id": "tmp.semgrep-rules.java.lang.security.audit.formatted-sql-string", "path": "src/main/java/eu/righettod/Vulns.java", "start": {"line": 15, "col": 13, "offset": 490}, "end": {"line": 15, "col": 37, "offset": 514}, "extra": {"message": "Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.", "metadata": {"cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"], "owasp": ["A01:2017 - Injection", "A03:2021 - Injection"], "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION", "asvs": {"control_id": "5.3.5 Injection", "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements", "section": "V5: Validation, Sanitization and Encoding Verification Requirements", "version": "4"}, "references": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html", "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps", "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"], "category": "security", "technology": ["java"], "cwe2022-top25": true, "cwe2021-top25": true, "subcategory": ["vuln"], "likelihood": "HIGH", "impact": "MEDIUM", "confidence": "MEDIUM"}, "severity": "ERROR", "fingerprint": "requires login", "lines": "requires login", "validation_state": "NO_VALIDATOR", "engine_kind": "OSS"}, "hints_for_analysis": {"details_as_text": "{\n  \"trace\": [\n    \"Entry Point: The input parameter 'name' is passed to the function 'realOne00'.\",\n    \"Data Flow: The 'name' parameter is used in a formatted string to construct an SQL query.\",\n    \"Vulnerability Check: The constructed SQL query uses String.format, which does not sanitize the input. This allows for SQL injection if 'name' contains malicious SQL code.\",\n    \"Sanitization/Validation: There is no sanitization or validation applied to the 'name' parameter before it is used in the SQL query.\",\n    \"Payload Formulation: A payload that could exploit this vulnerability would be something like ' OR '1'='1'. This payload would alter the SQL query to always return true, potentially exposing all user data.\"\n  ],\n  \"present\": \"yes\",\n  \"exploit\": \"' OR '1'='1'\",\n  \"reasoning_for_decision\": \"The input parameter 'name' is not sanitized before being used in a formatted string for an SQL query. This allows for SQL injection through the use of a malicious payload that alters the intended SQL command.\"\n}", "vuln_is_false_positive": false}}, {"check_id": "tmp.semgrep-rules.java.lang.security.audit.formatted-sql-string", "path": "src/main/java/eu/righettod/Vulns.java", "start": {"line": 25, "col": 13, "offset": 964}, "end": {"line": 25, "col": 37, "offset": 988}, "extra": {"message": "Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.", "metadata": {"cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"], "owasp": ["A01:2017 - Injection", "A03:2021 - Injection"], "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION", "asvs": {"control_id": "5.3.5 Injection", "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements", "section": "V5: Validation, Sanitization and Encoding Verification Requirements", "version": "4"}, "references": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html", "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps", "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"], "category": "security", "technology": ["java"], "cwe2022-top25": true, "cwe2021-top25": true, "subcategory": ["vuln"], "likelihood": "HIGH", "impact": "MEDIUM", "confidence": "MEDIUM"}, "severity": "ERROR", "fingerprint": "requires login", "lines": "requires login", "validation_state": "NO_VALIDATOR", "engine_kind": "OSS"}, "hints_for_analysis": {"details_as_text": "{\n  \"trace\": [\n    {\n      \"step\": \"Identify Entry Points\",\n      \"description\": \"The input parameter `name` is passed to the function `fakeOne00`. This parameter can be influenced by an upstream component.\"\n    },\n    {\n      \"step\": \"Trace Data Flow\",\n      \"description\": \"The `name` parameter flows through several transformations: `replaceAll(\"'\", \"\")`, `replaceAll(\"-\", \"\")`, `replaceAll(\"\\\\\", \" \")`, and `trim()`. The transformed data is then used in the SQL query string.\"\n    },\n    {\n      \"step\": \"Check for Sanitization/Validation\",\n      \"description\": \"The input undergoes multiple replacements to remove potentially harmful characters (`'`, `-`, `\\`). These transformations are designed to neutralize special elements that could modify the intended SQL command.\"\n    },\n    {\n      \"step\": \"Evaluate Effectiveness\",\n      \"description\": \"The replacements ensure that any single quotes, hyphens, backslashes, or leading/trailing spaces in the input are removed. This makes it impossible for the payload to be interpreted as SQL syntax.\"\n    },\n    {\n      \"step\": \"Formulate Payload\",\n      \"description\": \"Since the transformations neutralize all potential SQL injection vectors, no payload can exploit this vulnerability.\"\n    },\n    {\n      \"step\": \"Confirm Execution\",\n      \"description\": \"Given that the input is sanitized and transformed, the `String.format` call will not produce a vulnerable SQL query. The payload does not reach the vulnerable line.\"\n    }\n  ],\n  \"present\": \"no\",\n  \"exploit\": \"\",\n  \"reasoning_for_decision\": \"The transformations neutralize all potential SQL injection vectors, making it impossible for the payload to exploit this vulnerability.\"\n}", "vuln_is_false_positive": true}}, {"check_id": "tmp.semgrep-rules.java.lang.security.audit.formatted-sql-string", "path": "src/main/java/eu/righettod/Vulns.java", "start": {"line": 35, "col": 17, "offset": 1394}, "end": {"line": 35, "col": 41, "offset": 1418}, "extra": {"message": "Detected a formatted string in a SQL statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use a prepared statements (java.sql.PreparedStatement) instead. You can obtain a PreparedStatement using 'connection.prepareStatement'.", "metadata": {"cwe": ["CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"], "owasp": ["A01:2017 - Injection", "A03:2021 - Injection"], "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION", "asvs": {"control_id": "5.3.5 Injection", "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements", "section": "V5: Validation, Sanitization and Encoding Verification Requirements", "version": "4"}, "references": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html", "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps", "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"], "category": "security", "technology": ["java"], "cwe2022-top25": true, "cwe2021-top25": true, "subcategory": ["vuln"], "likelihood": "HIGH", "impact": "MEDIUM", "confidence": "MEDIUM"}, "severity": "ERROR", "fingerprint": "requires login", "lines": "requires login", "validation_state": "NO_VALIDATOR", "engine_kind": "OSS"}, "hints_for_analysis": {"details_as_text": "{\n  \"trace\": [\n    \"Entry Point: The function `fakeOne01` is called with an input parameter `name`. This parameter can be influenced by an upstream component.\",\n    \"Data Flow: The input `name` is passed to the regular expression `Pattern.matches(\\\"^[a-z]+$\\\", name)`, which checks if `name` consists only of lowercase letters. If it does, the code proceeds to construct an SQL query using `String.format(\\\"SELECT * FROM USERS WHERE LOGIN='%s'\\\", name);`.\",\n    \"Sanitization/Validation: The regular expression `Pattern.matches(\\\"^[a-z]+$\\\", name)` ensures that `name` contains only lowercase letters. This prevents any characters that could modify the intended SQL command, such as single quotes or semicolons.\",\n    \"Effectiveness of Controls: Since the input is sanitized by the regex to contain only lowercase letters, it cannot be used to inject malicious SQL code. The payload ' OR '1'='1' -- would not pass this regex check and thus would be rejected before reaching the vulnerable line.\"\n  ],\n  \"present\": \"no\",\n  \"exploit\": \"\",\n  \"reasoning_for_decision\": \"The regular expression `Pattern.matches(\\\"^[a-z]+$\\\", name)` effectively sanitizes the input, preventing any characters that could modify the SQL command. Therefore, the vulnerability is not present.\"\n}", "vuln_is_false_positive": true}}], "errors": [], "paths": {"scanned": [".gitignore", ".idea/.gitignore", ".idea/encodings.xml", ".idea/misc.xml", ".idea/vcs.xml", "pom.xml", "src/main/java/eu/righettod/Vulns.java"]}, "time": {"rules": [], "rules_parse_time": 0.16943001747131348, "profiling_times": {"config_time": 4.453056335449219, "core_time": 0.4501028060913086, "ignores_time": 0.00020241737365722656, "total_time": 4.90367579460144}, "parsing_time": {"total_time": 0.008381128311157227, "per_file_time": {"mean": 0.008381128311157227, "std_dev": 0.0}, "very_slow_stats": {"time_ratio": 0.0, "count_ratio": 0.0}, "very_slow_files": []}, "scanning_time": {"total_time": 0.03707265853881836, "per_file_time": {"mean": 0.004634082317352295, "std_dev": 0.00011994174621676734}, "very_slow_stats": {"time_ratio": 0.0, "count_ratio": 0.0}, "very_slow_files": []}, "matching_time": {"total_time": 0.013092279434204102, "per_file_and_rule_time": {"mean": 0.0008728186289469402, "std_dev": 7.056311450368313e-07}, "very_slow_stats": {"time_ratio": 0.0, "count_ratio": 0.0}, "very_slow_rules_on_files": []}, "tainting_time": {"total_time": 0.0029790401458740234, "per_def_and_rule_time": {"mean": 8.511543273925781e-05, "std_dev": 6.509799277409911e-09}, "very_slow_stats": {"time_ratio": 0.0, "count_ratio": 0.0}, "very_slow_rules_on_defs": []}, "fixpoint_timeouts": [], "targets": [], "total_bytes": 0, "max_memory_bytes": 163478656}, "engine_requested": "OSS", "skipped_rules": []}